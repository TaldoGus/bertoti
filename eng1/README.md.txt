We see three critical differences between programming and software engineering: time, scale, and the trade-offs at play. On a software engineering project, engineers need to be more concerned with the passage of time and the eventual need for change. In a software engineering organization, we need to be more concerned about scale and efficiency, both for the software we produce as well as for the organization that is producing it. Finally, as software engineers, we are asked to make more complex decisions with higher-stakes outcomes, often based on imprecise estimates of time and growth.


Within Google, we sometimes say, “Software engineering is programming integrated over time.” Programming is certainly a significant part of software engineering: after all, programming is how you generate new software in the first place. If you accept this distinction, it also becomes clear that we might need to delineate between programming tasks (development) and software engineering tasks (development, modification, maintenance). The addition of time adds an important new dimension to programming. Cubes aren’t squares, distance isn’t velocity. Software engineering isn’t programming.




_________________________________________________________
 COMENTÁRIO GUSTAVO VILLELA  

É ressaltada a importância de distinguir entre tarefas de programação e tarefas de engenharia de software, considerando a dimensão temporal. Em suma, o texto enfatiza que a engenharia de software não se limita apenas à programação, mas integra o desenvolvimento, modificação e manutenção do software ao longo do tempo.
( três aspectos essenciais: tempo, escala e os compromissos envolvidos(trades offs). )

1 - PROGRAMAÇÃO + TEMPO em Engenharia de software :
Entender "Programação + Tempo" na engenharia de software significa reconhecer que o desenvolvimento de software não se limita apenas à criação inicial do código, mas também envolve sua evolução ao longo do tempo. Isso significa considerar não apenas como escrever código inicialmente, mas também como esse código será mantido, modificado e adaptado no futuro.
______________

2 - ESCALA em Engenharia de Software :
Basicamente é a capacidade do sistema de crescer e se adaptar conforme necessário para atender às necessidades em constante evolução dos usuários e do negócio.
______________________

3 - TRADE OFFS em Engenharia de software :
Na engenharia de software, um conceito importante são os chamados "trade-offs", que são às escolhas que os engenheiros precisam fazer entre diferentes aspectos do desenvolvimento de software depedendo do processo e outros fatores. 
________________________________________


TRADE OFFS EXEMPLOS :

1- Por exemplo, um trade-off comum é entre usabilidade e segurança. Aumentar a segurança geralmente significa adicionar camadas extras de autenticação ou tornar os processos mais complexos, o que pode reduzir a usabilidade para os usuários. Por exemplo o GITHUB que agora para acessar se tornou dependente do acesso 2FA (autenticação), aumentou sua segurança para tornar o login mais demorado e "chato".

2 -  Outro exemplo é o trade-off entre velocidade de desenvolvimento e qualidade do código. Priorizar o lançamento rápido de novos recursos pode resultar em código menos organizado e propenso a erros. Como exemplo  Uma startup de entrega de alimentos pode optar por lançar rapidamente um aplicativo básico, sacrificando a qualidade do código para entrar no mercado mais cedo. Isso pode resultar em mais bugs e menor eficiência, mas permite ganhar tração rapidamente e iterar com base no feedback dos usuários. Conforme crescem, podem investir em melhorias na qualidade do código.

3 - Na meteorologia, o uso de linguagens de baixo nível para cálculos e análises é um trade-off entre eficiência computacional e complexidade no desenvolvimento. Linguagens como Fortran e C/C++ oferecem eficiência superior, permitindo lidar com dados complexos e realizar simulações precisas, porém exigem mais habilidades e tempo de desenvolvimento em comparação com linguagens de alto nível. Assim, a escolha da linguagem depende da necessidade de desempenho versus a complexidade no desenvolvimento do software meteorológico.




